{
     "algorithm": "An ensemble scoring algorithm that combines multiple independent scoring strategies (including constraint violation potential, variable flipping impact, and random walk) with a dynamic weighting mechanism based on recent improvement trends.",
     "code": "import numpy as np\n\ndef select_neighborhood(n, m, k, site, value, constraint, initial_solution, current_solution, objective_coefficient):\n    neighbor_score = np.zeros(n)\n    \n    strategy_scores = []\n    strategy_weights = np.ones(3)\n    \n    # Strategy 1: Constraint violation potential\n    violation_potential = np.zeros(n)\n    for i in range(m):\n        lhs = sum(value[i][j] * current_solution[site[i][j]] for j in range(k[i]))\n        slack = constraint[i] - lhs\n        if slack < 0:\n            for j in range(k[i]):\n                idx = site[i][j]\n                violation_potential[idx] += abs(value[i][j]) * abs(slack)\n    if violation_potential.max() > 0:\n        violation_potential = violation_potential / violation_potential.max()\n    strategy_scores.append(violation_potential)\n    \n    # Strategy 2: Variable flipping impact (estimated objective change)\n    flip_impact = np.zeros(n)\n    for idx in range(n):\n        if current_solution[idx] == 0:\n            flip_impact[idx] = objective_coefficient[idx]\n        else:\n            flip_impact[idx] = -objective_coefficient[idx]\n    flip_impact = np.abs(flip_impact)\n    if flip_impact.max() > 0:\n        flip_impact = flip_impact / flip_impact.max()\n    strategy_scores.append(flip_impact)\n    \n    # Strategy 3: Random walk with memory of recent changes\n    recent_change = np.abs(current_solution - initial_solution)\n    random_component = np.random.rand(n)\n    memory_random = 0.7 * random_component + 0.3 * recent_change\n    strategy_scores.append(memory_random)\n    \n    # Dynamic weighting based on correlation between strategies\n    correlation_matrix = np.zeros((3, 3))\n    for i in range(3):\n        for j in range(3):\n            if i != j:\n                corr = np.corrcoef(strategy_scores[i], strategy_scores[j])[0,1]\n                correlation_matrix[i,j] = 0 if np.isnan(corr) else abs(corr)\n    \n    diversity_score = 1 - np.mean(correlation_matrix, axis=1)\n    strategy_weights = diversity_score / diversity_score.sum()\n    \n    # Combine strategies with dynamic weights\n    for i in range(3):\n        neighbor_score += strategy_weights[i] * strategy_scores[i]\n    \n    # Add small noise for exploration\n    neighbor_score += 0.05 * np.random.randn(n)\n    \n    return neighbor_score",
     "objective": 5593.0294,
     "other_inf": null
}